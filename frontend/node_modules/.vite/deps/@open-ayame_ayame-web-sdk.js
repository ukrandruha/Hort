import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/@open-ayame+ayame-web-sdk@2025.1.1/node_modules/@open-ayame/ayame-web-sdk/dist/ayame.mjs
var h = "2025.1.1";
function l() {
  const a = window.navigator.userAgent.toLocaleLowerCase();
  return a.indexOf("edge") !== -1 ? "edge" : a.indexOf("chrome") !== -1 && a.indexOf("edge") === -1 ? "chrome" : a.indexOf("safari") !== -1 && a.indexOf("chrome") === -1 ? "safari" : a.indexOf("opera") !== -1 ? "opera" : a.indexOf("firefox") !== -1 ? "firefox" : "unknown";
}
function f(a, e) {
  let t = "";
  window.performance && (t = `[Ayame ${(window.performance.now() / 1e3).toFixed(3)}]`), l() === "edge" ? console.log(`${t} ${a}
`, e) : console.info(`${t} ${a}
`, e);
}
var p = (a, e, t) => t.filter((s) => {
  const i = s.mimeType.toLowerCase();
  return i === e.toLowerCase() || i === `${a}/rtx` || i === `${a}/red` || i === `${a}/ulpfec`;
});
var u = (a, e) => {
  var _a;
  if (typeof RTCRtpSender > "u" || typeof RTCRtpReceiver > "u")
    return [];
  const t = e === "sender" || e === "receiver" ? RTCRtpSender.getCapabilities : RTCRtpReceiver.getCapabilities;
  if (typeof t != "function")
    return [];
  const n = (_a = t(a)) == null ? void 0 : _a.codecs;
  return n ? n.filter((s) => {
    const i = s.mimeType.toLowerCase();
    return !(i === `${a}/rtx` || i === `${a}/red` || i === `${a}/ulpfec`);
  }).filter((s, i, o) => i === o.findIndex((c) => c.mimeType === s.mimeType)).map((s) => s.mimeType).sort() : [];
};
var r = class {
  /**
   * オブジェクトを生成し、リモートのピアまたはサーバーに接続します。
   */
  constructor(e, t, n, s = false, i = false) {
    __publicField(this, "debug");
    __publicField(this, "roomId");
    __publicField(this, "signalingUrl");
    __publicField(this, "options");
    __publicField(this, "connectionState");
    __publicField(this, "stream");
    __publicField(this, "remoteStream");
    __publicField(this, "authnMetadata");
    __publicField(this, "authzMetadata");
    __publicField(this, "ws");
    __publicField(this, "pc");
    __publicField(this, "callbacks");
    __publicField(this, "isOffer");
    __publicField(this, "isExistUser");
    __publicField(this, "dataChannels");
    __publicField(this, "pcConfig");
    this.debug = s, this.roomId = t, this.signalingUrl = e, this.options = n, this.stream = null, this.remoteStream = null, this.pc = null, this.ws = null, this.authnMetadata = null, this.authzMetadata = null, this.dataChannels = [], this.isOffer = false, this.isExistUser = false, this.connectionState = "new", this.pcConfig = {
      iceServers: this.options.iceServers,
      iceTransportPolicy: i ? "relay" : "all"
    }, this.callbacks = {
      open: () => {
      },
      connect: () => {
      },
      disconnect: () => {
      },
      addstream: () => {
      },
      bye: () => {
      },
      datachannel: () => {
      }
    };
  }
  get webSocket() {
    return this.ws;
  }
  get peerConnection() {
    return this.pc;
  }
  // biome-ignore lint/complexity/noBannedTypes: <explanation>
  on(e, t) {
    e in this.callbacks && (this.callbacks[e] = t);
  }
  /**
   * 接続する
   */
  async connect(e, t = null) {
    if (this.ws)
      throw this.traceLog("WebSocket Already Exists!"), new Error("WebSocket Already Exists!");
    if (this.pc)
      throw this.traceLog("RTCPeerConnection already exists"), new Error("RTCPeerConnection Already Exists!");
    this.stream = e, t && (this.authnMetadata = t.authnMetadata), await this.signaling();
  }
  /**
   * 接続を切断する
   */
  async disconnect() {
    for (const e of this.dataChannels)
      await this.closeDataChannel(e);
    await Promise.all([this.closePeerConnection(), this.closeWebSocketConnection()]), this.authzMetadata = null, this.isOffer = false, this.isExistUser = false, this.dataChannels = [], this.connectionState = "new";
  }
  /**
   * 統計情報を取得する
   */
  async getStats() {
    if (!this.pc)
      throw new Error("PeerConnection is not ready");
    return await this.pc.getStats();
  }
  async signaling() {
    return new Promise((e, t) => {
      if (this.ws)
        return t("WS-ALREADY-EXISTS");
      this.ws = new WebSocket(this.signalingUrl), this.ws.onclose = async () => {
        if (!this.options.standalone)
          return await this.disconnect(), this.callbacks.disconnect({ reason: "WS-CLOSED" }), t("WS-CLOSED");
      }, this.ws.onerror = async () => (await this.disconnect(), t("WS-CLOSED-WITH-ERROR")), this.ws.onopen = () => {
        const n = {
          type: "register",
          roomId: this.roomId,
          clientId: this.options.clientId,
          authnMetadata: void 0,
          key: void 0,
          standalone: this.options.standalone
        };
        this.authnMetadata !== null && (n.authnMetadata = this.authnMetadata), this.options.signalingKey !== null && (n.key = this.options.signalingKey), this.sendWs(n), this.ws && (this.ws.onmessage = async (s) => {
          try {
            if (typeof s.data != "string")
              return;
            const i = JSON.parse(s.data);
            if (i.type === "ping")
              this.sendWs({ type: "pong" });
            else {
              if (i.type === "bye")
                return this.callbacks.bye(s), e();
              if (i.type === "accept")
                return this.authzMetadata = i.authzMetadata, Array.isArray(i.iceServers) && i.iceServers.length > 0 && (this.traceLog("iceServers=>", i.iceServers), this.pcConfig.iceServers = i.iceServers), this.traceLog("isExistUser=>", i.isExistUser), this.isExistUser = i.isExistUser, this.createPeerConnection(), this.isExistUser === true && await this.sendOffer(), e();
              if (i.type === "reject")
                return await this.disconnect(), this.callbacks.disconnect({ reason: i.reason || "REJECTED" }), t("REJECTED");
              if (i.type === "offer")
                this.pc && this.pc.signalingState === "have-local-offer" && this.createPeerConnection(), this.setOffer(new RTCSessionDescription(i));
              else if (i.type === "answer")
                await this.setAnswer(new RTCSessionDescription(i));
              else if (i.type === "candidate" && i.ice) {
                this.traceLog("Received ICE candidate ...", i.ice);
                const o = new RTCIceCandidate(i.ice);
                this.addIceCandidate(o);
              }
            }
          } catch (i) {
            await this.disconnect(), this.callbacks.disconnect({ reason: "SIGNALING-ERROR", error: i });
          }
        });
      };
    });
  }
  async removeDataChannel(e) {
    const t = this.findDataChannel(e);
    if (t && t.readyState === "open")
      await this.closeDataChannel(t);
    else
      throw new Error("data channel is not exist or open");
  }
  setCodecPreferences(e, t, n, s) {
    if (this.traceLog(`${e} codecMimeType=`, t), !n.codecs.some((o) => o.mimeType === t) || typeof s.setCodecPreferences != "function")
      return;
    let i = [];
    i = p(e, t, n.codecs), this.traceLog(`${e} codecs=`, i), s.setCodecPreferences(i);
  }
  createPeerConnection() {
    this.traceLog("RTCConfiguration=>", this.pcConfig);
    const e = new RTCPeerConnection(this.pcConfig);
    if (this.stream && this.options.audio.direction !== "recvonly") {
      const t = this.stream.getAudioTracks();
      if (t.length > 0) {
        const n = t[0], s = e.addTrack(n, this.stream), i = this.getTransceiver(e, s);
        i && (i.direction = this.options.audio.direction);
        const o = RTCRtpSender.getCapabilities("audio");
        this.options.audio.enabled && this.options.audio.codecMimeType !== void 0 && i !== null && o !== null && this.setCodecPreferences(
          "audio",
          this.options.audio.codecMimeType,
          o,
          i
        );
      }
    } else if (this.options.audio.enabled) {
      const t = e.addTransceiver("audio", {
        direction: this.options.audio.direction
      }), n = RTCRtpReceiver.getCapabilities("audio");
      this.options.audio.enabled && this.options.audio.codecMimeType !== void 0 && n !== null && this.setCodecPreferences(
        "audio",
        this.options.audio.codecMimeType,
        n,
        t
      );
    }
    if (this.stream && this.options.video.direction !== "recvonly") {
      const t = this.stream.getVideoTracks();
      if (t.length > 0) {
        const n = t[0], s = e.addTrack(n, this.stream), i = this.getTransceiver(e, s);
        i && (i.direction = this.options.video.direction);
        const o = RTCRtpSender.getCapabilities("video");
        this.options.video.enabled && this.options.video.codecMimeType !== void 0 && i !== null && o !== null && this.setCodecPreferences(
          "video",
          this.options.video.codecMimeType,
          o,
          i
        );
      }
    } else if (this.options.video.enabled) {
      const t = e.addTransceiver("video", {
        direction: this.options.video.direction
      }), n = RTCRtpReceiver.getCapabilities("video");
      this.options.video.enabled && this.options.video.codecMimeType !== void 0 && t !== null && n !== null && this.setCodecPreferences(
        "video",
        this.options.video.codecMimeType,
        n,
        t
      );
    }
    e.ontrack = (t) => {
      if (this.remoteStream)
        return;
      this.traceLog("peer.ontrack()", t), this.remoteStream = t.streams[0];
      const n = {
        type: "addstream",
        stream: this.remoteStream
      };
      this.callbacks.addstream(n);
    }, e.onicecandidate = (t) => {
      this.traceLog("peer.onicecandidate()", t), t.candidate ? this.sendIceCandidate(t.candidate) : this.traceLog("empty ice event", "");
    }, e.oniceconnectionstatechange = async () => {
      if (this.traceLog("ICE connection Status has changed to ", e.iceConnectionState), this.connectionState !== e.iceConnectionState)
        switch (this.connectionState = e.iceConnectionState, this.connectionState) {
          case "connected":
            this.isOffer = false, this.callbacks.connect();
            break;
          case "disconnected":
          case "failed":
            await this.disconnect(), this.callbacks.disconnect({ reason: "ICE-CONNECTION-STATE-FAILED" });
            break;
        }
    }, e.onconnectionstatechange = async (t) => {
      e.connectionState === "connected" ? this.options.standalone && (this.sendWs({ type: "connected" }), this.ws && (this.traceLog("websocket is closed"), this.ws.close(), this.ws = null)) : e.connectionState === "closed" && (this.traceLog("peer connection is closed"), await this.disconnect());
    }, e.onsignalingstatechange = (t) => {
      this.traceLog("signaling state changes:", e.signalingState);
    }, e.ondatachannel = this.onDataChannel.bind(this), this.pc ? this.pc = e : (this.pc = e, this.callbacks.open({ authzMetadata: this.authzMetadata }));
  }
  async createDataChannel(e, t) {
    return new Promise((n, s) => {
      if (!this.pc) return s("PeerConnection Does Not Ready");
      if (this.isOffer) return s("PeerConnection Has Local Offer");
      let i = this.findDataChannel(e);
      return i ? s("DataChannel Already Exists!") : this.isExistUser ? (i = this.pc.createDataChannel(e, t), i.onclose = (o) => {
        this.traceLog("datachannel onclosed=>", o), this.dataChannels = this.dataChannels.filter((c) => c.label !== e);
      }, i.onerror = (o) => {
        this.traceLog("datachannel onerror=>", o), this.dataChannels = this.dataChannels.filter((c) => c.label !== e);
      }, i.onmessage = (o) => {
        this.traceLog("datachannel onmessage=>", o.data), o.label = e;
      }, i.onopen = (o) => {
        this.traceLog("datachannel onopen=>", o);
      }, this.dataChannels.push(i), n(i)) : n(null);
    });
  }
  onDataChannel(e) {
    if (this.traceLog("on data channel", e), !this.pc) return;
    const t = e.channel, n = e.channel.label;
    e.channel && (!n || n.length < 1 || (t.onopen = async (s) => {
      this.traceLog("datachannel onopen=>", s);
    }, t.onclose = async (s) => {
      this.traceLog("datachannel onclosed=>", s);
    }, t.onerror = async (s) => {
      this.traceLog("datachannel onerror=>", s);
    }, t.onmessage = (s) => {
      this.traceLog("datachannel onmessage=>", s.data), s.label = n;
    }, this.findDataChannel(n) ? this.dataChannels = this.dataChannels.map((s) => s.label === n ? t : s) : this.dataChannels.push(e.channel), this.callbacks.datachannel(t)));
  }
  async sendOffer() {
    if (!this.pc)
      return;
    const e = await this.pc.createOffer({
      offerToReceiveAudio: this.options.audio.enabled && this.options.audio.direction !== "sendonly",
      offerToReceiveVideo: this.options.video.enabled && this.options.video.direction !== "sendonly"
    });
    this.traceLog("create offer sdp, sdp=", e.sdp), await this.pc.setLocalDescription(e), this.pc.localDescription && this.sendSdp(this.pc.localDescription), this.isOffer = true;
  }
  isAudioCodecSpecified() {
    return this.options.audio.enabled && this.options.audio.codecMimeType !== void 0;
  }
  isVideoCodecSpecified() {
    return this.options.video.enabled && this.options.video.codecMimeType !== void 0;
  }
  async createAnswer() {
    if (this.pc)
      try {
        const e = await this.pc.createAnswer();
        this.traceLog("create answer sdp, sdp=", e.sdp), await this.pc.setLocalDescription(e), this.pc.localDescription && this.sendSdp(this.pc.localDescription);
      } catch (e) {
        await this.disconnect(), this.callbacks.disconnect({ reason: "CREATE-ANSWER-ERROR", error: e });
      }
  }
  async setAnswer(e) {
    this.pc && (await this.pc.setRemoteDescription(e), this.traceLog("set answer sdp=", e.sdp));
  }
  async setOffer(e) {
    try {
      if (!this.pc)
        return;
      await this.pc.setRemoteDescription(e), this.traceLog("set offer sdp=", e.sdp), await this.createAnswer();
    } catch (t) {
      await this.disconnect(), this.callbacks.disconnect({ reason: "SET-OFFER-ERROR", error: t });
    }
  }
  async addIceCandidate(e) {
    try {
      this.pc && await this.pc.addIceCandidate(e);
    } catch {
      this.traceLog("invalid ice candidate", e);
    }
  }
  sendIceCandidate(e) {
    const t = { type: "candidate", ice: e };
    this.sendWs(t);
  }
  sendSdp(e) {
    this.sendWs(e);
  }
  sendWs(e) {
    this.ws && this.ws.send(JSON.stringify(e));
  }
  getTransceiver(e, t) {
    let n = null;
    for (const s of e.getTransceivers())
      (s.sender === t || s.receiver === t) && (n = s);
    if (!n)
      throw new Error("invalid transceiver");
    return n;
  }
  findDataChannel(e) {
    return this.dataChannels.find((t) => t.label === e);
  }
  async closeDataChannel(e) {
    return this.traceLog("close data channel"), new Promise((t) => {
      if (!e)
        return this.traceLog("data channel is null"), t();
      if (e.readyState === "closed")
        return this.traceLog("data channel is closed"), t();
      e.onclose = null;
      const n = setInterval(() => {
        if (e.readyState === "closed")
          return clearInterval(n), this.traceLog("data channel is closed"), t();
      }, 200);
      e.close();
    });
  }
  async closePeerConnection() {
    return this.traceLog("close peer connection"), new Promise((e) => {
      if (!this.pc)
        return this.traceLog("peer connection is null"), e();
      if (this.pc.connectionState === "closed")
        return this.pc = null, this.traceLog("peer connection is closed"), e();
      this.pc.oniceconnectionstatechange = null;
      const t = setInterval(() => {
        if (!this.pc)
          return clearInterval(t), this.traceLog("peer connection is null"), e();
        if (this.pc.connectionState === "closed")
          return this.pc = null, clearInterval(t), this.traceLog("peer connection is closed"), e();
      }, 200);
      this.pc.close();
    });
  }
  async closeWebSocketConnection() {
    return new Promise((e) => {
      if (!this.ws)
        return this.traceLog("websocket is null"), e();
      if (this.ws && this.ws.readyState === WebSocket.CLOSED)
        return this.ws = null, this.traceLog("websocket is closed"), e();
      this.ws.onclose = null;
      const t = setInterval(() => {
        if (!this.ws)
          return clearInterval(t), this.traceLog("websocket is null"), e();
        if (this.ws.readyState === WebSocket.CLOSED)
          return this.ws = null, clearInterval(t), this.traceLog("websocket is closed"), e();
      }, 200);
      this.ws.close();
    });
  }
  traceLog(e, t) {
    this.debug && f(e, t);
  }
};
var d = {
  audio: { direction: "sendrecv", enabled: true },
  video: { direction: "sendrecv", enabled: true },
  iceServers: [],
  clientId: crypto.randomUUID()
};
var g = (a, e, t = d, n = false, s = false) => new r(a, e, t, n, s);
var C = (a, e, t = d, n = false, s = false) => new r(a, e, t, n, s);
var w = () => h;
export {
  g as connection,
  C as createConnection,
  r as default,
  d as defaultOptions,
  u as getAvailableCodecs,
  w as version
};
/*! Bundled license information:

@open-ayame/ayame-web-sdk/dist/ayame.mjs:
  (**
   * @open-ayame/ayame-web-sdk
   * WebRTC Signaling Server Ayame Web SDK
   * @version: 2025.1.1
   * @author: Shiguredo Inc.
   * @license: Apache-2.0
   **)
*/
//# sourceMappingURL=@open-ayame_ayame-web-sdk.js.map
